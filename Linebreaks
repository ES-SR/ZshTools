
## print a terminal width linebreak of given characters, defaults to "-" if no characters passed
function print:linebreak {
	local Chars=${1:-"-"}
  
	local LineBreak=$(printf "echo \${(l:\$(tput cols)::%s:)\$(echo %s)}" $Chars)

	eval $LineBreak
}



## print a terminal width linebreak with a centered message

function print:linebreak:message {
	local Message=${1}
	local Chars=${2:-"-"}
	local -i HalfWidth=$(( $(tput cols) / 2 ))
	
	local EvalStr='print -P - "${(l:'
	EvalStr="${EvalStr}${HalfWidth}"
	EvalStr+='::'
	EvalStr="${EvalStr}${Chars}"
	EvalStr+=':: :r:'
	EvalStr="${EvalStr}${HalfWidth}"
	EvalStr+='::'
	EvalStr="${EvalStr}${Chars}"
	EvalStr+=':: :)Message}"'
	
	#echo $EvalStr
	eval $EvalStr
}


## print a terminal width linebreak with a justified message
 # second argument uses a comma (,) delimited ratio of left space to right space
 # e.g. 1,1 2,2 etc will center a message 0,1 will left justify the message 1,0 will right justify
 # can pass left side fill characters and right side fill characters
 # right side chars default to the left side chars if not passed
 # left side chars defualt to "-" if not passed ( right side will also be "-" )
function print:linebreak:message:justify {
	local Text="${1}"
	local -a Ratio=( ${(s:,:)2:-"1,1,"} )
	local LeftFillChars=${3:-"-"}
	local RightFillChars=${4:-${LeftFillChars}}

	local -i LeftRatio="${Ratio[1]}"
	local -i RightRatio="${Ratio[2]}"

	local -i TermWidth="$(tput cols)"

	local -i TotalParts=$(( LeftRatio + RightRatio ))
	local -i PartSize=$(( TermWidth / TotalParts ))

	local -i LeftSize=$(( LeftRatio * PartSize ))
	local -i RightSize=$(( TermWidth - LeftSize ))

	echo -n "${(%pl:$LeftSize::$LeftFillChars:r:$RightSize::$RightFillChars:)Text}"
}


## Examples (output using an 80 column terminal)

# linebreak without args
% print:linebreak     
--------------------------------------------------------------------------------
%

# linebreak with custom character
% print:linebreak +   
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%

# linebreak with custom characters
% print:linebreak +-
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
%

# message break without args
% print:linebreak:message "hello world"                           
---------------------------------- hello world ---------------------------------
%

# message break with custom fill characters
% print:linebreak:message "hello world" +=
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+= hello world +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
%

# using print:linebreak:message:justify to create progress bar
% Min=1; Max=10
  tput sc
  for I ( {$Min..$Max} ) {
    local L=I; local R=$(( Max - L ))
    tput rc ;tput ed
    print:linebreak:message:justify " ${$(( L * 1.0 / Max * 100. ))/\.*/}%% " $L,$R "=" "."
    sleep 1
  }
============== 20% .............................................................

# as above but using the alternate buffer
% Min=1; Max=10
  tput sc; tput smcup; tput civis
  for I ( {$Min..$Max} ) {
    local L=I
    local R=$(( Max - L ))
    tput cup 0 0 ;tput el1
    print:linebreak:message:justify " ${$(( L * 1.0 / Max * 100. ))/\.*/}%% " $L,$R "=" "."
    sleep .5
  }
  tput rmcup; tput rc; tput cnorm
============================================== 60% .............................

