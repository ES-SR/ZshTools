#!/bin/zsh

##########################################
#####          Version 2 
##########################################

## pattern builder
#
function @args:word2pattern:v2 {
        local Word="${(b)1:?}"

        local ValueFlag=${${${(M)Word%=}:+true}:-false}
        ( $ValueFlag ) && {
                Word=${Word%=}
                ValueFlag="[= ]* "
                #print "true" 
        } || {
                #print "false"
                ValueFlag=""
        }

        local ShortFlag="(--|-)["$(  \
                <<<                            \
                ${(j.][.)$(                    \
                        for P ( ${(As.-.)Word} ) {
                                <<<                                \
                                ${(U)P[1]}${(L)P[1]}
                        })}                              \
        )"]"

        local LongFlag="(--|-|)"$(  \
                <<<                            \
                ${(j.(-|).)$(                  \
                        for P ( ${(As.-.)Word} ) {
                                <<<                                \
                                ${P//#[a-zA-Z0-9]/[${(U)P[1]}${(L)P[1]}]}
                        })}                              \
        )
  
        local PATTERN="((${ShortFlag})|(${LongFlag}))${ValueFlag}"
        typeset -p PATTERN
}

:<<-"DOCS.word2pattern"
  # the version from before is still used, as this example shows
  <<| @args:word2pattern:v2 test-word
  > typeset PATTERN='(((--|-)[Tt][Ww])|((--|-|)[Tt]est(-|)[Ww]ord))'
  # now includes a version to make value extraction easier. just a a trailing "=" to the option name
  <<| @args:word2pattern:v2 test-word-with-value=                       
  > typeset PATTERN='(((--|-)[Tt][Ww][Ww][Vv])|((--|-|)[Tt]est(-|)[Ww]ord(-|)[Ww]ith(-|)[Vv]alue))[= ]* '
[mike@tardis]/home/mike%   
DOCS.word2pattern

##  bool args
# set flag words as boolean variables
function @args:bool:v2 {
        local Args=( ${(P)1:?} )
        eval $(@args:word2pattern:v2 ${2:?})
        local ${2}=${${${(M)Args##${~PATTERN}}:+true}:-false}
        typeset -p ${2}
}


:<<-"EXAMPLE.USAGE"
  <<| Targs=( first second third fourth )                               
  <<| @args:bool:v2 Targs debug                                         
  > typeset debug=false
  <<| Targs=( first -debug second third fourth )
  <<| @args:bool:v2 Targs debug                 
  > typeset debug=true
  <<| eval $(@args:bool:v2 Targs debug)                                 
  <<| ( $debug ) && { print "do this" } || { print "do something else" }
  > do this
  <<| Targs=( first second third fourth )                               
  <<| eval $(@args:bool:v2 Targs debug)                                 
  <<| ( $debug ) && { print "do this" } || { print "do something else" }
  > do something else
EXAMPLE.USAGE






## default argument-pattern builder
######

function args:word2pattern {
  local Word="${(b)1:?}"
  local ShortFlag="(-|--)["$(  \
    <<<                            \
    ${(j.][.)$(                    \
      for P ( ${(As.-.)Word} ) {
        <<<                                \
        ${(U)P[1]}${(L)P[1]}
      })}                              \
    )"]"
  local LongFlag="(-|--|)"$(  \
    <<<                            \
    ${(j.(-|).)$(                  \
      for P ( ${(As.-.)Word} ) {
        <<<                                \
        ${P//#[a-zA-Z0-9]/[${(U)P[1]}${(L)P[1]}]}
      })}                              \
  )
  echo "($ShortFlag)|($LongFlag)"
}

:<<-'EXAMPLE.word2pattern'
  ~% args:word2pattern local-port-more-hyphens
  ((-|--)[Ll][Pp][Mm][Hh])|((-|--|)[Ll]ocal(-|)[Pp]ort(-|)[Mm]ore(-|)[Hh]yphens)
  ~% ExampleArgs=( some localport args --Local-Port here -V and local-Port more -lpmh )
  ~% print -l - ${(M)ExampleArgs##${~$(args:word2pattern local-port-more-hyphens)}}
  -lpmh
EXAMPLE.word2pattern


## set a bool value based on if a argument matches a patter
######

function args:patternMatch:bool {
  echo ${${@[(r)${~PATTERN}]:+true}:-false}
}

:<<-'EXAMPLE.args:patternMatch:bool'
  %~ PATTERN='(-[vV]|(-|--|)[vV]erbose)'
  %~ Verbose=$(args:patternMatch:bool some args here -V and more)
  %~${Verbose} && { exec 3>&1 } || { exec 3>/dev/null }
EXAMPLE.args:patternMatch:bool


## display output of a function when an argument matches a pattern
######

function args:patternMatch:functionOutput {
  <<< ${${(*M)@##${~PATTERN}}:+$(eval "${OUTPUT_FUNCTION}")}
}

:<<-'EXAMPLE.args:patternMatch:functionOutput'
  %~ PATTERN='((-|--)([hH](elp|))|((-|--|)([hH]elp)))'
  %~ function testHelp {
  %~   cat<<-'EOF'
  %~     test help
  %~     output
  %~   EOF
  %~ }
  %~ OUTPUT_FUNCTION='testHelp'
  %~ args:patternMatch:functionOutput -h two help 4 -H Help seven --help 9 --Help
  test help output
  %~ args:patternMatch:functionOutput 1 two 3 4 5 6 seven 8 9

EXAMPLE.args:patternMatch:functionOutput


## extract value following a " " (space) or "=" (equal sign) of argument matching a pattern
######

function args:patternMatch:value {
  local Pattern="$PATTERN(=| )"
  <<< ${${(R)${(*M)"${*}"##${~Pattern}*}##*(=| )}:-${DEFAULT_VALUE}}
}

:<<-'EXAMPLE.args:patternMatch:value'
  %~ PATTERN='((-|--)([lL](og|))|((-|--|)([lL]og)))'
  %~ DEFAULT_VALUE='/dev/null'
  %~ args:patternMatch:value
  /dev/null
  %~ args:patternMatch:value -l
  /dev/null
  %~ args:patternMatch:value -l=dir/file
  dir/file
  %~ args:patternMatch:value -l dir/file
  dir/file
EXAMPLE.args:patternMatch:value
