#!/bin/zsh


## levenshtein comparison
######

function string:compare:levenshtein {
    local Str1="$1"
    local Str2="$2"
    local Str1Len=${#Str1}
    local Str2Len=${#Str2}
    
    # Create matrix using associative array
    typeset -A CompareMatrix
    
    # Initialize first row and column
    for I ( {0..$Str1Len} ) {
        CompareMatrix[$I,0]=$I
    }
    
    for J ( {0..$Str2Len} ) {
        CompareMatrix[0,$J]=$J
    }
    
    # Fill the matrix
    for I ( {1..$Str1Len} ) {
        for J ( {1..$Str2Len} ) {
            local Cost=1
            [[ "${Str1[$I]}" = "${Str2[$J]}" ]] && Cost=0
            
            local Deletions=$((CompareMatrix[$((I-1)),$J] + 1))
            local Insertions=$((CompareMatrix[$I,$((J-1))] + 1))
            local Substitutions=$((CompareMatrix[$((I-1)),$((J-1))] + Cost))
            
            # Find minimum
            local Min=$Deletions
            [[ $Insertions -lt $Min ]] && Min=$Insertions
            [[ $Substitutions -lt $Min ]] && Min=$Substitutions
            
            CompareMatrix[$I,$J]=$Min
	}
    }
    
    echo ${CompareMatrix[$Str1Len,$Str2Len]}
}

# examples
~% string:compare:levenshtein sitting kitten              
# 3
~% string:compare:levenshtein cat mat               
# 1


## hamming comparison
######

function string:compare:hamming {
    local Str1="$1"
    local Str2="$2"
    local StrLen=${#Str1}

    if [[ ${#Str2} -ne ${StrLen} ]] { 
        echo "Error: Strings must have equal length" >&2
        return 1
    }

    local Distance=$StrLen
    for I ( {1..$StrLen} ) {
        (( Distance -= ${(N)Str1[$I]:#${Str2[$I]}} ))
    }
    echo $Distance
}

# examples
~% string:compare:hamming cat hat   
# 1
~% string:compare:hamming kitten sit-in
# 3
~% string:compare:hamming announce denounce
# 2
